### STILL WIP

"""
Used to track both the underlying asset that is protected by a vault and the vault token itself
"""
type Token @entity(immutable: true) {
  id: Bytes!
  name: String!
  symbol: String!
  decimals: BigInt!
}

type Block @entity(immutable: true) {
  id: Bytes!
  number: BigInt!
  timestamp: BigInt!
}

"""
Used to track an Hedging Vault; id is the address of the InvestmentVault contract
"""
type HedgingVault @entity {
  id: Bytes!
  "address of the PotionBuyAction that the vault will use to perform hedging rounds"
  action: PotionBuyAction
  "the address that is authorized to run operations like starting a new round"
  operator: Bytes
  "the address that is authorized to run operations like purchasing/selling tokens"
  admin: Bytes
  "the address that is authorized to tweak the vault parameters"
  strategist: Bytes
  "the asset that is deposited in the vault to be protected"
  underlying: Token!
  "the token supplied by the vault to rappresent user shares"
  shareToken: Token!
  "the amount of underlyings that have been invested into the vault"
  totalAssets: BigInt!
  "the total amount of shareTokens that have been supplied by the vault"
  totalShares: BigInt!
  lastUnderlyingsInvested: BigInt
  lastUnderlyingToShareRate: BigInt
  lastShareToUnderlyingRate: BigInt
  currentRound: BigInt
  "an array of rounds that the vault has executed or is still executing"
  rounds: [Round!] @derivedFrom(field: "vault")
}

"""
The settings used by a vault to execute hedging rounds on the Potion Protocol; id is the address of the PotionBuyAction contract
"""
type PotionBuyAction @entity {
  id: Bytes!
  vault: HedgingVault
  cycleDurationSecs: BigInt!
  hedgingRate: BigInt!
  maxPremiumPercentage: BigInt!
  maxSwapDurationSecs: BigInt!
  nextCycleStartTimestamp: BigInt!
  premiumSlippage: BigInt!
  strikePercentage: BigInt!
  swapSlippage: BigInt!
}

type Round @entity {
  id: Bytes!
  vault: HedgingVault!
  roundNumber: BigInt!
  "exchangeRate provided in the nextRound event of roundsInputVault"
  underlyingToShareRate: BigInt
  "exchangeRate provided in the nextRound event of roundsOutputVault"
  shareToUnderlyingRate: BigInt
  totalUnderlyingsAtRoundEnd: BigInt
  underlyingsInvested: BigInt
  depositTickets: [DepositTicket!]!
  withdrawalTickets: [WithdrawalTicket!]!
  # implementation note: depositTickets and withdrawalTickets MUST be an array and not a derived field because in the mappings API it is not possible to access a derived field; without this access it would be impossible to do calculations at nextRound()
  blockEntered: Block
  blockExited: Block
  deposit: Deposit
  withdrawal: Withdrawal
}

"""
This entity is used to keep track of all the addresses that have provided liquidity at least one time; can be a wallet or a contract
"""
type Investor @entity {
  id: Bytes!
  user: Bytes!
  vaults: [HedgingVault!]! # we are storing the vaults as an array because we aren't currently interested into having the vault -> investor relation; if we need it in the future we will need an auxiliary entity
  depositTickets: [DepositTicket!] @derivedFrom(field: "investor")
  withdrawalTickets: [WithdrawalTicket!] @derivedFrom(field: "investor")
}

"""
This entity is used to keep track of all the deposits that an InvestmentVault performed
"""
type Deposit @entity {
  id: Bytes!
  round: Round!
  amount: BigInt!
  shareAmount: BigInt!
  block: Block!
  tx: Bytes!
}

"""
This entity is used to keep track of all the withdrawals that an InvestmentVault performed
"""
type Withdrawal @entity {
  id: Bytes!
  round: Round!
  amount: BigInt!
  shareAmount: BigInt!
  block: Block!
  tx: Bytes!
}

"""
This entity keeps track of a deposit request that an Investor did; the id is composed using vault address + round number + investor addresses.
Only one DepositTicket per Investor can exist in a round, if an Investor request multiple deposits the ticket will be simply updated
"""
type DepositTicket @entity {
  id: Bytes!
  sender: Bytes!
  investor: Investor!
  round: Round!
  "the amount of underlyings that the Investor deposited; it can change only if the ticket is updated, when this liquidity changes after a withdraw the change is tracked in amountRemaining and amountRedeemed"
  amount: BigInt!
  amountRemaining: BigInt!
  amountRedeemed: BigInt!
  "calculated at nextRound() multiplying amount with the round underlyingToShareRate"
  shares: BigInt!
  sharesRemaining: BigInt!
  sharesRedeemed: BigInt!
  block: Block!
  tx: Bytes!
}

"""
This entity keeps track of a withdrawal request that an Investor did; the id is composed using vault address + round number + investor addresses.
Only one WithdrawalTicket per Investor can exist in a round, if an Investor request multiple withdraws the ticket will be simply updated
"""
type WithdrawalTicket @entity {
  id: Bytes!
  sender: Bytes!
  investor: Investor!
  round: Round!
  "the amount of underlyings that the Investor can withdraw; it can change only if the ticket is updated, when this liquidity changes after a withdraw the change is tracked in amountRemaining and amountRedeemed"
  amount: BigInt!
  amountRedeemed: BigInt!
  amountRemaining: BigInt!
  "calculated at nextRound() multiplying amount with the round shareToUnderlyingRate"
  underlyings: BigInt!
  underlyingsRedeemed: BigInt!
  underlyingsRemaining: BigInt!
  block: Block!
  tx: Bytes!
}
