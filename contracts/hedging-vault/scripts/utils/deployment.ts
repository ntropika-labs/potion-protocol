import { config as dotenvConfig } from "dotenv";
import { Contract, Signer } from "ethers";
import fs from "fs";
import hre, { ethers, network, upgrades } from "hardhat";
import { FactoryOptions } from "hardhat/types";
import { resolve } from "path";

dotenvConfig({ path: resolve(__dirname, "../../.env") });

const NUM_CONFIRMATIONS_WAIT = 5;
const deploymentsDir = resolve(__dirname, "../../deployments");
const indexDir = resolve(__dirname, "../../src");

const DEPLOYMENTS_INDEX_FILE = "index.ts";

export enum DeploymentFlags {
    Deploy = 1 << 0,
    DeployAndVerify = 1 << 1,
}

export interface DeploymentOptions extends FactoryOptions {
    flags?: DeploymentFlags;
    alias?: string; // The deployed contract will be exported in the JSON file with this alias
}

export function isDeploymentOptions(options: Signer | DeploymentOptions | undefined): options is DeploymentOptions {
    return (
        options !== undefined &&
        ((options as DeploymentOptions).flags !== undefined || (options as DeploymentOptions).alias !== undefined)
    );
}

export async function initDeployment() {
    // Initialize deployment info
    const latestDeploymentFilename = network.name + ".json";
    const latestDeploymentPath = resolve(deploymentsDir, latestDeploymentFilename);

    // Cycle the previous deployment info to keep a history of deployments. When deploying to localhost
    // only the latest deployment is kept.
    if (network.name !== "localhost" && network.name !== "hardhat" && fs.existsSync(latestDeploymentPath)) {
        const latestDeployment = JSON.parse(fs.readFileSync(latestDeploymentPath, "utf8"));
        const timestamp = latestDeployment.timestamp;

        const newDeploymentPath = resolve(deploymentsDir, network.name + "-" + timestamp + ".json");
        fs.renameSync(latestDeploymentPath, newDeploymentPath);
    }

    const deploymentsObject = {
        timestamp: Math.floor(new Date().getTime() / 1000),
        network: network.name,
        contracts: {},
    };

    fs.writeFileSync(latestDeploymentPath, JSON.stringify(deploymentsObject, null, 2));
}

export async function exportDeployments() {
    const allDeploymentFiles = fs.readdirSync(deploymentsDir);

    // Filter out all deployment files that have a timestamp in them
    const latestDeploymentFiles = allDeploymentFiles.filter(
        fileName => fileName.endsWith(".json") && !/\d/.test(fileName),
    );

    const indexFilePath = resolve(indexDir, DEPLOYMENTS_INDEX_FILE);

    // Not using a stream write here because it simplifies the code and there are only
    // 3 writes in total
    fs.writeFileSync(indexFilePath, `// Autogenerated by the deployments script\n`, "utf8");
    fs.appendFileSync(indexFilePath, `export * as Typechain from "../typechain";`, "utf8");

    const deploymentExport = {};

    latestDeploymentFiles.forEach(file => {
        const deployment = JSON.parse(fs.readFileSync(resolve(deploymentsDir, file), "utf8"));
        const deploymentName = file.replace(".json", "");

        Object.assign(deploymentExport, { [deploymentName]: deployment });
    });

    fs.appendFileSync(
        indexFilePath,
        `\nexport const Deployments = ${JSON.stringify(deploymentExport, null, 2)}`,
        "utf8",
    );
}

export async function exportContract(name: string, address: string, blockNumber: number) {
    // Export deployment info
    const latestDeploymentFilename = network.name + ".json";
    const latestDeploymentPath = resolve(deploymentsDir, latestDeploymentFilename);

    if (!fs.existsSync(latestDeploymentPath)) {
        throw new Error("initDeployment must be called first before calling deploy");
    }

    const latestDeployment = JSON.parse(fs.readFileSync(latestDeploymentPath, "utf8"));
    latestDeployment.contracts[name] = { address, blockNumber };
    fs.writeFileSync(latestDeploymentPath, JSON.stringify(latestDeployment, null, 2));
}

export async function verify(contractAddress: string, args: unknown[]): Promise<boolean> {
    try {
        await hre.run("verify:verify", {
            address: contractAddress,
            constructorArguments: args,
        });
    } catch (error) {
        console.error(error);
        return false;
    }

    return true;
}

export async function deploy(
    contractName: string,
    args: unknown[] = [],
    options: Signer | DeploymentOptions | undefined = undefined,
): Promise<Contract> {
    const contractFactory = await ethers.getContractFactory(contractName, options);
    const contract = await contractFactory.deploy(...args);
    const transactionReceipt = await contract.deployTransaction.wait();

    let flags = undefined,
        alias = undefined;
    if (isDeploymentOptions(options)) {
        flags = options.flags;
        alias = options.alias;
    }

    if (alias) {
        await exportContract(alias, contract.address, transactionReceipt.blockNumber);
    } else {
        await exportContract(contractName, contract.address, transactionReceipt.blockNumber);
    }

    if (flags && (flags & DeploymentFlags.DeployAndVerify) === DeploymentFlags.DeployAndVerify) {
        await contract.deployTransaction.wait(NUM_CONFIRMATIONS_WAIT);
        await verify(contract.address, args);
    }

    return contract.deployed();
}

export async function deployUpgrade(
    contractName: string,
    args: unknown[] = [],
    options: Signer | DeploymentOptions | undefined = undefined,
): Promise<Contract> {
    const contractFactory = await ethers.getContractFactory(contractName, options);
    const contract = await upgrades.deployProxy(contractFactory, args);
    const transactionReceipt = await contract.deployTransaction.wait();

    let flags = undefined,
        alias = undefined;
    if (isDeploymentOptions(options)) {
        flags = options.flags;
        alias = options.alias;
    }

    if (alias) {
        await exportContract(alias, contract.address, transactionReceipt.blockNumber);
    } else {
        await exportContract(contractName, contract.address, transactionReceipt.blockNumber);
    }

    if (flags && (flags & DeploymentFlags.DeployAndVerify) === DeploymentFlags.DeployAndVerify) {
        await contract.deployTransaction.wait(NUM_CONFIRMATIONS_WAIT);
        await verify(contract.address, args);
    }

    return contract.deployed();
}
